<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>useChess Solver</title>
		<style>
			.game {
				display: flex;
				gap: 1em;
			}
			.board {
				display: grid;
				grid-template-columns: repeat(4, 50px);
			}
			.cell {
				width: 50px;
				height: 50px;
				border: 1px solid black;
				text-align: center;
			}
			/* Set default light squares */
			.cell {
				background-color: beige;
			}

			/* Manually set dark squares based on their position in the grid */
			.cell:nth-child(2), 
			.cell:nth-child(4), 
			.cell:nth-child(5), 
			.cell:nth-child(7), 
			.cell:nth-child(10),
			.cell:nth-child(12),
			.cell:nth-child(13),
			.cell:nth-child(15) {
				background-color: orange;
			}
			.pieces,
			.colors {
				display: flex;
				margin-bottom: 10px;
			}
			.piece,
			.color {
				margin: 0 5px;
			}
			textarea {
				width: 100%;
				height: 50vh;
			}
		</style>
	</head>
	<body>
		<div class="game">
			<div class="selection">
				<div class="pieces">
					<label class="piece"><input type="radio" name="piece" value="p" />Pawn</label>
					<label class="piece"><input type="radio" name="piece" value="b" />Bishop</label>
					<label class="piece"><input type="radio" name="piece" value="n" />Knight</label>
					<label class="piece"><input type="radio" name="piece" value="r" />Rook</label>
					<label class="piece"><input type="radio" name="piece" value="q" />Queen</label>
					<label class="piece"><input type="radio" name="piece" value="k" />King</label>
				</div>
				<div class="pieces">
					<label class="piece"
						><input type="radio" name="piece" value="x" />Blocked</label
					>
					<label class="piece"><input type="radio" name="piece" value="." />Empty</label>
				</div>
				<hr />

				<div class="colors">
					<label class="color"><input type="radio" name="color" value="R" />Red</label>
					<label class="color"><input type="radio" name="color" value="L" />Blue</label>
					<label class="color"><input type="radio" name="color" value="B" />Black</label>
				</div>
			</div>

			<div class="board" id="board">
				<!-- Cells will be generated by JavaScript -->
			</div>
		</div>

		<button id="solve">Solve!</button>

		<textarea id="solution" readonly></textarea>

		<script>
			const board = document.getElementById("board");
			const solutionTextarea = document.getElementById("solution");
			solutionTextarea.value = "";

			// Generates the board
			for (let row = 4; row >= 1; row--) {
				for (let col of ["A", "B", "C", "D"]) {
					const cell = document.createElement("div");
					cell.innerText = "..";
					cell.className = "cell";
					cell.id = col + row;
					cell.addEventListener("click", () => selectCell(col + row));
					board.appendChild(cell);
				}
			}

			// Handles cell selection
			function selectCell(cellId) {
				const piece = document.querySelector('input[name="piece"]:checked').value;
				const color =
					piece === "x"
						? "x"
						: piece === "."
						? "."
						: document.querySelector('input[name="color"]:checked').value;
				const cell = document.getElementById(cellId);
				cell.textContent = color + piece;
			}

			// Solve the puzzle
			document.getElementById("solve").addEventListener("click", () => {
				const boardState = [];
				for (let row = 4; row >= 1; row--) {
					let rowState = "";
					for (let col of ["A", "B", "C", "D"]) {
						const cell = document.getElementById(col + row);
						rowState += cell.textContent || "..";
					}
					boardState.push(rowState);
				}
				const solution = solve(boardState.join("\n"));
				if (solution.length === 0) {
					solutionTextarea.value = "No valid solution for the given input!!";
				} else {
					solutionTextarea.value = solution
						.map((state, i) => `Step ${i + 1}\n` + state + "\n--------\n")
						.join("");
				}
			});

			function parseInput(input) {
				const boardMap = new Map();
				const rows = input.split("\n");
				const columns = ["A", "B", "C", "D"];

				rows.forEach((row, rowIndex) => {
					for (let colIndex = 0; colIndex < row.length; colIndex += 2) {
						const piece = row.substring(colIndex, colIndex + 2);
						const key = columns[colIndex / 2] + (4 - rowIndex).toString();
						boardMap.set(key, piece);
					}
				});

				return boardMap;
			}

			function printBoardState(boardState) {
				let boardString = "";
				for (let row = 4; row >= 1; row--) {
					for (const col of ["A", "B", "C", "D"]) {
						boardString += boardState.get(col + row) || "..";
					}
					boardString += row > 1 ? "\n" : "";
				}
				return boardString;
			}

			function getPossibleMovesForPiece(piece, fromLocation) {
				const moves = new Set();
				const col = fromLocation.charCodeAt(0);
				const row = parseInt(fromLocation[1], 10);
				const pieceType = piece[1];

				// Directions for rook, bishop, and queen
				// prettier-ignore
				const directions = {
					rook: [[1, 0], [-1, 0], [0, 1], [0, -1]],
					bishop: [[1, 1], [1, -1], [-1, 1], [-1, -1]],
					queen: [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]],
					knight: [[1, 2], [2, 1], [-1, 2], [2, -1], [-1, -2], [-2, -1], [1, -2], [-2, 1]],
				};

				// Helper function to add moves in a direction
				function addMovesInDirection(direction) {
					let [dc, dr] = direction;
					let c = col,
						r = row;
					while (true) {
						c += dc;
						r += dr;
						if (c < "A".charCodeAt(0) || c > "D".charCodeAt(0) || r < 1 || r > 4) break;
						moves.add(String.fromCharCode(c) + r);
					}
				}

				switch (pieceType) {
					case "p": // Pawn
						if (row < 4) {
							if (col > "A".charCodeAt(0))
								moves.add(String.fromCharCode(col - 1) + (row + 1));
							if (col < "D".charCodeAt(0))
								moves.add(String.fromCharCode(col + 1) + (row + 1));
						}
						break;
					case "r": // Rook
						directions.rook.forEach(addMovesInDirection);
						break;
					case "b": // Bishop
						directions.bishop.forEach(addMovesInDirection);
						break;
					case "n": // Knight
						directions.knight.forEach((d) => {
							let c = col + d[0];
							let r = row + d[1];
							if (
								c >= "A".charCodeAt(0) &&
								c <= "D".charCodeAt(0) &&
								r >= 1 &&
								r <= 4
							) {
								moves.add(String.fromCharCode(c) + r);
							}
						});
						break;
					case "q": // Queen
						directions.queen.forEach(addMovesInDirection);
						break;
					case "k": // King
						for (let dc = -1; dc <= 1; dc++) {
							for (let dr = -1; dr <= 1; dr++) {
								if (dc === 0 && dr === 0) continue;
								let c = col + dc,
									r = row + dr;
								if (
									c >= "A".charCodeAt(0) &&
									c <= "D".charCodeAt(0) &&
									r >= 1 &&
									r <= 4
								) {
									moves.add(String.fromCharCode(c) + r);
								}
							}
						}
						break;
				}

				return moves;
			}

			function getValidMoves(boardState) {
				const validMoves = [];

				function createNewState(from, to, pieceType, board) {
					const newState = new Map(board);
					const toPiece = newState.get(to);

					// Handle special case of red piece capture
					if (toPiece && toPiece.startsWith("R")) {
						newState.set(to, pieceType.charAt(0) + toPiece.charAt(1));
					} else {
						newState.set(to, pieceType);
					}

					newState.set(from, "..");
					return newState;
				}

				function handlePawnPromotions(from, to, board) {
					const promotions = ["b", "n", "r", "q"];
					promotions.forEach((promotion) => {
						validMoves.push(createNewState(from, to, "B" + promotion, board));
					});
				}

				function isPathBlocked(from, to) {
					const fromCol = from.charCodeAt(0);
					const fromRow = parseInt(from[1], 10);
					const toCol = to.charCodeAt(0);
					const toRow = parseInt(to[1], 10);
					const colStep = Math.sign(toCol - fromCol);
					const rowStep = Math.sign(toRow - fromRow);

					let checkCol = fromCol + colStep;
					let checkRow = fromRow + rowStep;

					while (checkCol !== toCol || checkRow !== toRow) {
						const square = String.fromCharCode(checkCol) + checkRow;
						if (
							boardState.get(square) === "xx" ||
							(boardState.get(square) !== ".." &&
								!(checkCol === toCol && checkRow === toRow))
						) {
							return true;
						}
						checkCol += colStep;
						checkRow += rowStep;
					}
					return false;
				}

				for (const [location, piece] of boardState) {
					if (piece.startsWith("B")) {
						// Only black pieces can move
						const possibleMoves = getPossibleMovesForPiece(piece, location);

						for (const move of possibleMoves) {
							const targetPiece = boardState.get(move);
							const isBlocked = piece.endsWith("n")
								? false
								: isPathBlocked(location, move);
							if (
								targetPiece &&
								targetPiece !== ".." &&
								targetPiece !== "xx" &&
								!isBlocked
							) {
								if (piece === "Bp" && move[1] === "4") {
									if (targetPiece.startsWith("R")) {
										// Swap with red piece
										validMoves.push(
											createNewState(
												location,
												move,
												"B" + targetPiece.charAt(1),
												boardState
											)
										);
									} else {
										// Normal pawn promotion
										handlePawnPromotions(location, move, boardState);
									}
								} else {
									const newState = createNewState(
										location,
										move,
										piece,
										boardState
									);
									validMoves.push(newState);
								}
							}
						}
					}
				}

				return validMoves;
			}

			function buildAllBoardStatesGraph(startState) {
				const graph = new Map();
				const visited = new Set();
				const queue = [startState];

				while (queue.length > 0) {
					const currentState = queue.shift();
					const currentStateStr = printBoardState(currentState);

					if (visited.has(currentStateStr)) continue;
					visited.add(currentStateStr);

					const children = getValidMoves(currentState).map((state) =>
						printBoardState(state)
					);

					graph.set(currentStateStr, children);

					for (const child of children) {
						if (!visited.has(child)) {
							queue.push(parseInput(child));
						}
					}
				}

				return graph;
			}

			function solve(startStateStr) {
				const startState = parseInput(startStateStr);
				const allBoardStates = buildAllBoardStatesGraph(startState);
				const queue = [[startStateStr]];
				const visited = new Set();

				while (queue.length > 0) {
					const path = queue.shift();
					const currentStateStr = path[path.length - 1];

					if (visited.has(currentStateStr)) continue;
					visited.add(currentStateStr);

					const currentState = parseInput(currentStateStr);
					const piecesCount = Array.from(currentState.values()).filter(
						(p) => p !== ".." && p !== "xx"
					).length;

					// Check if this is the solution
					if (piecesCount === 1) {
						return path;
					}

					const children = allBoardStates.get(currentStateStr) || [];
					for (const child of children) {
						if (!visited.has(child)) {
							queue.push([...path, child]);
						}
					}
				}

				return []; // Return an empty array if no solution is found
			}
		</script>
	</body>
</html>
